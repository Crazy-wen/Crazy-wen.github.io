<!DOCTYPE html>
<html lang="zh-CN">








<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/img/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content>
    <meta name="author" content="Crazy-wen">
    <meta name="keywords" content>
    <title>一步一步构建Ucore操作系统(Lab 1) ~ Crazy-wen&#39;s Blog</title>
    <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css?v=5.7.2">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/bootstrap.min.css?v=4.3.1">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css?v=4.8.7">
    <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
    <link rel="stylesheet" href="/lib/nprogress/nprogress.css?v=0.2.0">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
    
        <link rel="stylesheet" href="/lib/prettify/atelier-seaside-light.min.css">
    
    <link rel="stylesheet" href="/css/main.css">
    
    
<script type="text/javascript">

 <script>
var _hmt = _hmt || [];
_hmt.push(['_setPageTag', id, value]);
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d2c7132109d78f54ab072ec83dfe40e1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




</head>


<body>
<header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>Crazy-wen&#39;s Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/categories/">Categories</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/tags/">Tags</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2"
         style="background: url('/img/post.jpg')no-repeat center center;background-size: cover;">
        <div class="full-bg-img">
            <div class="mask rgba-black-light flex-center">
                <div class="container text-center white-text wow fadeInUp">
                    <span  class="h1"  id="subtitle">
                        
                    </span>
                    
                        <br>
                        <p>Thursday, August 29th 2019, 9:17 pm</p>
                    
                </div>
            </div>
        </div>
    </div>
</header>

<main>
    
        




<div class="container-fluid">
    <div class="row">
        <div class="d-none d-lg-block col-lg-2"></div>
            <div class="col-lg-8 nopadding-md">
                <div class="py-5 z-depth-3 board">
                    <div class="post-content mx-auto">
                        <div class="markdown-body">
                            <h1 id="0x00-实验准备"><a href="#0x00-实验准备" class="headerlink" title="0x00 实验准备"></a>0x00 实验准备</h1><h3 id="源代码网址"><a href="#源代码网址" class="headerlink" title="源代码网址:"></a>源代码网址:</h3><blockquote>
<p><a href="http://www.github.com/chyyuu/ucorebook\_code" target="_blank" rel="noopener">http://www.github.com/chyyuu/ucorebook\_code</a></p>
</blockquote>
<h3 id="下载全部源代码到本地"><a href="#下载全部源代码到本地" class="headerlink" title="下载全部源代码到本地"></a>下载全部源代码到本地</h3><blockquote>
<p>git clone git://github.com/chyyuu/ucore_os_lab.git<br>cd ucore_os_lab<br>git pull         #更新</p>
</blockquote>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><pre><code>虚拟机： Ubuntu
实验工具： 
  系统维护工具： apt，git
  源码阅读与编辑工具： Eclipse-CDT、understand、gedit、vim
  源码比较工具：dif, meld
  开发编译调试工具：gcc、gdb、make
  硬件模枞器：qemu</code></pre><hr>
<h1 id="0x01-Lab-1"><a href="#0x01-Lab-1" class="headerlink" title="0x01 Lab 1"></a>0x01 Lab 1</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><blockquote>
<p>操作系统是一个软件，也需要通过某种手段加载并运行它，由于硬件实现较为复杂，在这里我们将通过另外一个更加简单的软件-bootloader来完成这些工作。为此，我们需要完成一个能够<strong>切换到x86的保护模式并显示字符的bootloader</strong>，为将来启动操作系统做准备。proj1提供了一个非常小的bootloader，整个bootloader的大小小于512个字节，这样才能放到硬盘的主引导扇区中</p>
</blockquote>
<h3 id="BootLoader是什么"><a href="#BootLoader是什么" class="headerlink" title="BootLoader是什么"></a>BootLoader是什么</h3><blockquote>
<p>在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</p>
</blockquote>
<blockquote>
<p>在嵌入式系统中，通常并没有像BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。</p>
</blockquote>
<h3 id="BootLoader主要完成的功能"><a href="#BootLoader主要完成的功能" class="headerlink" title="BootLoader主要完成的功能"></a>BootLoader主要完成的功能</h3><ul>
<li>初始化寄存器内容</li>
<li>实模式到保护模式的转换</li>
<li>在保护模式下通过PIO方式控制串口、并口和CGA等进行字符串输出</li>
</ul>
<h3 id="lab1的主要文件"><a href="#lab1的主要文件" class="headerlink" title="lab1的主要文件"></a>lab1的主要文件</h3><pre><code>    lab1 /
    |-- boot
    |   |-- asm.h
    |   |-- bootasm.S
    |   |-- bootmain.c
    |-- libs
    |-- Makefile
    |-- tools
        |-- gdbinit
        |-- sign.c
        |-- function.mk</code></pre><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><ul>
<li>bootasm.S ：定义并实现了bootloader最先执行的函数start，此函数进行了一定的初始化，完成了从实模式到保护模式的转换，并调用bootmain.c中的bootmain函数。</li>
<li>bootmain.c：定义并实现了bootmain函数实现了通过屏幕、串口和并口显示字符串。</li>
<li>asm.h：是bootasm.S汇编文件所需要的头文件，主-要是一些与X86保护模式的段访问方式相关的宏定义。</li>
<li>Makefile和function.mk：指导make完成整个软件项目的编译，清除等工作。</li>
<li>sign.c：一个C语言小程序，是辅助工具，用于生成一个符合规范的硬盘主引导扇区。</li>
<li>gdbinit：用于gdb远程调试的初始命令脚本</li>
</ul>
<hr>
<h1 id="0x02-相关知识"><a href="#0x02-相关知识" class="headerlink" title="0x02 相关知识"></a>0x02 相关知识</h1><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><blockquote>
<p>80386的实模式是为了与8086处理器兼容而设置的。在实模式下，80386处理器就相当于一个快速的8086处理器。80386处理器被复位或加电的时候以实模式启动。这时候处理器中的各寄存器以实模式的初始化值工作。80386处理器在实模式下的存储器寻址方式和8086基本一致。在实模式下，80386处理器不能对内存进行分页机制的管理，所以指令寻址的地址就是内存中实际的物理地址。在实模式下，所有的段都是可以读、写和执行的。实模式下80386不支持优先级，所有的指令相当于工作在特权级（即优先级0），所以它可以执行所有特权指令。这实际上使得在实模式下不太可能设计一个有保护能力的操作系统。实模式下不支持硬件上的多任务切换。实模式下的中断处理方式和8086处理器相同，也用中断向量表来定位中断服务程序地址。应用程序可以任意修改中断向量表的内容，使得计算机系统容易受到病毒、木马等的攻击，整个计算机系统的安全性无法得到保证。</p>
</blockquote>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><blockquote>
<p>通过保护模式，可以把虚拟地址空间映射到不同的物理地址空间，且在超出预设的空间范围会报错（一种保护机制的体现），且可以保证处于低特权级的代码无法访问高特权级的数据（另外一种保护机制的体现）。 只有在保护模式下，80386的全部32位地址才能有效，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2^14个段，每个段最大空间为2^32字节）的虚拟地址空间，可采用分段存储管理机制和分页存储管理机制。</p>
</blockquote>
<h3 id="GDT-全局描述符表"><a href="#GDT-全局描述符表" class="headerlink" title="GDT(全局描述符表)"></a>GDT(全局描述符表)</h3><blockquote>
<p>GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，CPU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。</p>
</blockquote>
<blockquote>
<p>在保护模式下，对内存的访问仍能使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。当你访问的偏移量超出段的界限时，处理器就会阻止这种访问，并产生一个叫做内部异常的中断。</p>
</blockquote>
<h3 id="LDT（局部描述符表）"><a href="#LDT（局部描述符表）" class="headerlink" title="LDT（局部描述符表）"></a>LDT（局部描述符表）</h3><blockquote>
<p>一张GDT可以包含多个LDT，LDT的用法与GDT大致相似<br>LDT不是全局可见的，它们只对引用它们的任务可见，每个任务最多可以拥有一个LDT。另外，每一个LDT自身作为一个段存在，它们的段描述符被放在GDT中</p>
</blockquote>
<h3 id="IDT（中断描述符表）"><a href="#IDT（中断描述符表）" class="headerlink" title="IDT（中断描述符表）"></a>IDT（中断描述符表）</h3><blockquote>
<p>作用：将每个异常或中断向量分别与它们的处理过程联系起来。<br>与GDT和LDT表类似，IDT也是由8字节长描述符组成的一个数组</p>
</blockquote>
<hr>
<h1 id="练习1：-理解通过make生成执行文件的过程"><a href="#练习1：-理解通过make生成执行文件的过程" class="headerlink" title="练习1： 理解通过make生成执行文件的过程"></a>练习1： 理解通过make生成执行文件的过程</h1><h2 id="生成ucore-img"><a href="#生成ucore-img" class="headerlink" title="生成ucore.img"></a>生成ucore.img</h2><pre><code class="shell">cd ucore_os_lab/labcodes/lab1
make              //生成bootloader和对应的主引导扇区
make qemu         //通过qemu硬件模拟器来运行bootloader</code></pre>
<p>至此，在./bin/下就有了<strong>ucore.img</strong>了</p>
<h2 id="从Makefile中看ucore-img的生成"><a href="#从Makefile中看ucore-img的生成" class="headerlink" title="从Makefile中看ucore.img的生成"></a>从Makefile中看ucore.img的生成</h2><p><strong>1. 生成kernel</strong></p>
<ul>
<li><p>首先是<code>$(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)$</code>这一段代码，含义是寻找libs目录下的所有具有.c, .s后缀的文件，并生成相应的.o文件，放置在obj/libs/文件夹下，具体生成的文件是printfmt.o, string.o文件，与此同时，该文件夹下还生成了.d文件，这是Makefile自动生成的依赖文件列表所存放的位置，比如打开string.d文件可以发现，string.o文件的生成依赖于string.c, string.h, x86.h, defs.h四个文件.</p>
</li>
<li><p><code>$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS)</code>这一段代码将用于生成kernel的所有子目录下包含的CTYPE文件（.s, .c文件）所对应的.o文件以及.d文件，这段代码与上述生成obj/libs/*.o文件的代码类似，区别仅在于其还新指定了若干gcc编译选项，存放在KCFLAGS变量中，具体为制定了若干存放在KINCLUDE变量下的头文件；具体而言，该命令最终生成的文件为obj/kern下子目录里的以stdio, readline, panic, kdebug, kmonitor, clock, console, picirq, intr, trap, vector, trapentry, pmm为前缀的.d, .o文件；</p>
</li>
</ul>
<ul>
<li>接下来<code>$(kernel): tools/kernel.ld</code>表示/bin/kernel文件依赖于tools/kernel.ld文件，并且没有指定生成规则，也就是说如果没有预先准备好kernel.ld，就会在make的时候产生错误；之后的<code>$(kernel): $(KOBJS)</code>表示kernel文件的生成还依赖于上述生成的obj/libs, obj/kernels下的.o文件，并且生成规则为使用ld链接器将这些.o文件连接成kernel文件，其中ld的-T表示指定使用kernel.ld来替代默认的链接器脚本</li>
</ul>
<p><strong>2. 生成bootblock文件：</strong></p>
<ul>
<li>首先是<code>$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc)</code>这一段代码，表示将boot/文件夹下的bootasm.S, bootmain.c两个文件编译成相应的.o文件，并且生成依赖文件.d；其中涉及到的两个gcc编译选项含义如下所示：<ul>
<li>-nostdinc: 不搜索默认路径头文件</li>
<li>-0s: 针对生成代码的大小进行优化，这是因为bootloader的总大小被限制为不大于512-2=510字节</li>
</ul>
</li>
<li>接下来由代码<code>$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign</code>可知，bootblock依赖于bootasm.o, bootmain.o文件与sign文件，其中两个.o文件由以下规则生成：<ul>
<li><code>$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)</code>: 使用ld链接器将依赖的.o文件链接成bootblock.o文件，该文件中除了<code>$(LDFLAGS)</code>之外的其他选项含义如下：<ul>
<li>-N：将代码段和数据段设置为可读可写</li>
<li>-e：设置入口</li>
<li>-Ttext：设置起始地址为0X7C00</li>
</ul>
</li>
</ul>
</li>
<li><code>@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</code>: 使用objdump将编译结果反汇编出来，保存在bootclock.asm中，-S表示将源代码与汇编代码混合表示</li>
<li><code>@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</code>: 使用objcopy将bootblock.o二进制拷贝到bootblock.out，其中：<ul>
<li>-S：表示移除符号和重定位信息</li>
<li>-O：表示指定输出格式</li>
</ul>
</li>
<li><code>@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</code>: 使用sign程序, 利用bootblock.out生成bootblock;</li>
<li><code>$(call add_files_host,tools/sign.c,sign,sign</code>: 利用tools/sing.c生成sign.o, $(call create_target_host,sign,sign)则利用sign.o生成sign，至此bootblock所依赖的文件均生成完毕；</li>
</ul>
<p><strong>3. 最后一个部分是利用dd命令使用bootblock, kernel文件来生成ucore.img文件</strong></p>
<ul>
<li><code>$(V)dd if=/dev/zero of=$@ count=10000</code> 命令表示从/dev/zero文件中获取10000个block，每一个block为512字节，并且均为空字符，并且输出到目标文件ucore.img中</li>
<li><code>$(V)dd if=$(bootblock) of=$@ conv=notrunc</code> 命令表示从bootblock文件中获取数据，并且输出到目标文件ucore.img中，-notruct选项表示不要对数据进行删减</li>
<li><code>$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc</code> 命令表示从kernel文件中获取数据，并且输出到目标文件ucore.img中, 并且seek = 1表示跳过第一个block，输出到第二个块</li>
</ul>
<p><strong>4. makefile语法</strong></p>
<ul>
<li>2&gt;&amp;1(将错误输出一起输出到标准输出里)<ul>
<li>1 表示标准输出，sstdout</li>
<li>2 表示标准错误，stderr</li>
<li>&amp; 为不创建文件，若去掉 &amp; 则输出到</li>
<li>ls xxx 2&gt;1测试，没有xxx这个文件的错误输出到了1中</li>
<li>ls xxx 2&gt;&amp;1测试，不会生成1这个文件了，不过错误跑到标准输出了</li>
<li>ls xxx &gt;out.txt 2&gt;&amp;1, 实际上可换成 ls xxx 1&gt;out.txt 2&gt;&amp;1；重定向符号&gt;默认是1,错误和输出都传到out.txt了</li>
</ul>
</li>
<li>bash命令<ul>
<li>mkdir -p: 允许创建嵌套子目录</li>
<li>touch -c: 不创建已经存在的文件</li>
<li>rm -f: 无视任何确认提示<blockquote>
<p>更多基本语法请查看参考资料</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h2><p><strong>该扇区最后两个字节为0x55AA；（该扇区有512个字节）</strong></p>
<h1 id="练习2：使用qemu执行并调试lab1中的软件"><a href="#练习2：使用qemu执行并调试lab1中的软件" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件"></a>练习2：使用qemu执行并调试lab1中的软件</h1><h2 id="bootloader加电后"><a href="#bootloader加电后" class="headerlink" title="bootloader加电后"></a>bootloader加电后</h2><ul>
<li>在/lab1/tools/gdbinit中设置：<pre><code class="shell">file bin/kernel
set arch i8086
target remote :1234
b *0xffff0</code></pre>
</li>
<li>在lab1目录下执行<code>gdb  -x tools/gdbinit</code>使gdb处于等待连接状态</li>
<li>在新窗口lab1目录下执行<code>make debug</code><pre><code class="shell">[----------------------------------registers-----------------------------------]
EAX: 0x0 (0x00000000)
EBX: 0x0 (0x00000000)
ECX: 0x0 (0x00000000)
EDX: 0x663 --&gt; 0x0 (0x00000000)
ESI: 0x0 (0x00000000)
EDI: 0x0 (0x00000000)
EBP: 0x0 (0x00000000)
ESP: 0x0 (0x00000000)
EIP: 0xfff0 --&gt; 0x0 (0x00000000)
EFLAGS: 0x2 (carry parity adjust zero sign trap interrupt direction overflow)
[-------------------------------------code-------------------------------------]
0xffea:    add    BYTE PTR [eax],al
0xffec:    add    BYTE PTR [eax],al
0xffee:    add    BYTE PTR [eax],al
=&gt; 0xfff0:    add    BYTE PTR [eax],al
0xfff2:    add    BYTE PTR [eax],al
0xfff4:    add    BYTE PTR [eax],al
0xfff6:    add    BYTE PTR [eax],al
0xfff8:    add    BYTE PTR [eax],al
[------------------------------------stack-------------------------------------]
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGTRAP
0x0000fff0 in ?? ()
Breakpoint 1 at 0xffff0
gdb-peda$ x /i 0xffff0
0xffff0:    jmp    0x3630:0xf000e05b
gdb-peda$ 
</code></pre>
</li>
</ul>
<pre><code>+ 此时CPU从物理地址0xFFFFFFF0（由初始化的CS：EIP确定，此时CS和IP的值分别是0xF000和0xFFF0)）开始执行。在0xFFFFFFF0这里只是存放了一条跳转指令，通过跳转指令跳到BIOS例行程序起始点。
+  BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。

## 在初始化位置0x7c00 设置实地址断点,测试断点正常
</code></pre><p>b *0x7c00<br>c</p>
<pre><code>## 在初始化位置0x7c00开始跟踪代码运行，与bootasm.S代码比较

![Ku1Mfe.png][image-1]

# 练习3：分析bootloader进入保护模式的过程
bootloader中从实模式进到保护模式的代码保存在lab1/boot/bootasm.S文件下，使用x86汇编语言编写，接下来将根据源码分析进入保护模式的过程：

bootloader入口为start, 根据bootloader的相关知识可知，bootloader会被BIOS加载到内存的0x7c00处，此时cs=0, eip=0x7c00，在刚进入bootloader的时候，最先执行的操作分别为关闭中断、清除EFLAGS的DF位以及将ax, ds, es, ss寄存器初始化为0；
</code></pre><p>.globl start<br>start:<br>.code16                                             # Assemble for 16-bit mode<br>    cli                                             # Disable<br>    cld                                             # String operations increment</p>
<pre><code># Set up the important data segment registers (DS, ES, SS).
xorw %ax, %ax                                   # Segment number zero
movw %ax, %ds                                   # -&gt; Data Segment
movw %ax, %es                                   # -&gt; Extra Segment
movw %ax, %ss                                   # -&gt; Stack Segment</code></pre><pre><code>
接下来为了使得CPU进入保护模式之后能够充分使用32位的寻址能力，需要开启A20，关闭“回卷”机制；该过程主要分为等待8042控制器Inpute Buffer为空，发送P2命令到Input Buffer，等待Input Buffer为空，将P2得到的第二个位（A20选通）置为1，写回Input Buffer；接下来对应上述步骤分析bootasm中的汇编代码：

首先是从0x64内存地址中（映射到8042的status register）中读取8042的状态，直到读取到的该字节第二位（input buffer是否有数据）为0，此时input buffer中无数据；
</code></pre><p>seta20.1:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.1</p>
<pre><code>movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64
outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</code></pre><pre><code>接下来往0x64写入0xd1命令，表示修改8042的P2 port；</code></pre><p>movb $0xd1, %al<br>outb %al, $0x64</p>
<pre><code>接下来继续等待input buffer为空：</code></pre><p>seta20.2:<br>    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).<br>    testb $0x2, %al<br>    jnz seta20.2</p>
<pre><code>movb $0xdf, %al                                 # 0xdf -&gt; port 0x60
outb %al, $0x60                                 # 0xdf = 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</code></pre><pre><code>
接下来往0x60端口写入0xDF，表示将P2 port的第二个位（A20）选通置为1；
</code></pre><p>movb $0xdf, %al<br>outb %al, $0x60</p>
<pre><code>
至此，A20开启，进入保护模式之后可以充分使用4G的寻址能力；

接下来需要设置GDT（全局描述符表），在bootasm.S中已经静态地描述了一个简单的GDT，如下所示; 值得注意的是GDT中将代码段和数据段的base均设置为了0，而limit设置为了2^32-1即4G，此时就使得逻辑地址等于线性地址，方便后续对于内存的操作；
</code></pre><h1 id="Bootstrap-GDT"><a href="#Bootstrap-GDT" class="headerlink" title="Bootstrap GDT"></a>Bootstrap GDT</h1><p>.p2align 2                                          # force 4 byte alignment<br>gdt:<br>    SEG_NULLASM                                     # null seg<br>    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel<br>    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</p>
<p>gdtdesc:<br>    .word 0x17                                      # sizeof(gdt) - 1<br>    .long gdt     </p>
<pre><code>
因此在完成A20开启之后，只需要使用命令lgdt gdtdesc即可载入全局描述符表；接下来只需要将cr0寄存器的PE位置1，即可从实模式切换到保护模式：</code></pre><pre><code>movl %cr0, %eax
orl $CR0_PE_ON, %eax
movl %eax, %cr0</code></pre><pre><code>接下来则使用一个长跳转指令，将cs修改为32位段寄存器，以及跳转到protcseg这一32位代码入口处，此时CPU进入32位模式：</code></pre><pre><code>ljmp $PROT_MODE_CSEG, $protcseg</code></pre><pre><code>接下来执行的32位代码功能为：设置ds、es, fs, gs, ss这几个段寄存器，然后初始化栈的frame pointer和stack pointer，然后调用使用C语言编写的bootmain函数，进行操作系统内核的加载，至此，bootloader已经完成了从实模式进入到保护模式的任务；


# 0x07 阅读源代码

+ btttmain.c
+ def.h
+ x86.h
+ elf.h

## bootmain.c源代码
```C
#include &lt;defs.h&gt;       
//定义类型、指针的位数，以及对地址的处理
#include &lt;x86.h&gt;        
//定义I/O输入输出，处理描述符表的汇编指令，以及用汇编编写字符串处理函数
#include &lt;elf.h&gt;
//定义elf文件头以及进程头信息

/* *********************************************************************
 * This a dirt simple boot loader, whose sole job is to boot
 * an ELF kernel image from the first IDE hard disk.
 *
 * DISK LAYOUT
 *  * This program(bootasm.S and bootmain.c) is the bootloader.
 *    It should be stored in the first sector of the disk.
 *
 *  * The 2nd sector onward holds the kernel image.
 *
 *  * The kernel image must be in ELF format.
 *
 * BOOT UP STEPS
 *  * when the CPU boots it loads the BIOS into memory and executes it
 *
 *  * the BIOS intializes devices, sets of the interrupt routines, and
 *    reads the first sector of the boot device(e.g., hard-drive)
 *    into memory and jumps to it.
 *
 *  * Assuming this boot loader is stored in the first sector of the
 *    hard-drive, this code takes over...
 *
 *  * control starts in bootasm.S -- which sets up protected mode,
 *    and a stack so C code then run, then calls bootmain()
 *
 *  * bootmain() in this file takes over, reads in the kernel and jumps to it.
 * */

#define SECTSIZE        512
#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space

/* waitdisk - wait for disk ready */
//等待磁盘就绪
static void
waitdisk(void) {
    while ((inb(0x1F7) &amp; 0xC0) != 0x40)
        /* do nothing */;
}

/* readsect - read a single sector at @secno into @dst */
//读取段
static void
readsect(void *dst, uint32_t secno) {
    // wait for disk to be ready
    waitdisk();

    outb(0x1F2, 1);                         // count = 1
    outb(0x1F3, secno &amp; 0xFF);
    outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);
    outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);
    outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);
    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors

    // wait for disk to be ready
    waitdisk();

    // read a sector
    //读取一个扇区
    insl(0x1F0, dst, SECTSIZE / 4);
}

/* *
 * readseg - read @count bytes at @offset from kernel into virtual address @va,
 * might copy more than asked.
 * */
//readseg - 将@offset上的@count字节从内核读入虚拟地址@va
//读段寄存器值
static void
readseg(uintptr_t va, uint32_t count, uint32_t offset) {
    uintptr_t end_va = va + count;

    // round down to sector boundary
    //向下到扇区边界
    va -= offset % SECTSIZE;

    // translate from bytes to sectors; kernel starts at sector 1
    //从字节转换为扇区;内核从扇区1开始
    uint32_t secno = (offset / SECTSIZE) + 1;

    // If this is too slow, we could read lots of sectors at a time.
    // We&#39;d write more to memory than asked, but it doesn&#39;t matter --
    // we load in increasing order.
    for (; va &lt; end_va; va += SECTSIZE, secno ++) {
        readsect((void *)va, secno);
    }
}

/* bootmain - the entry of bootloader */
void
bootmain(void) {
    // read the 1st page off disk
    //从磁盘上读取段寄存器值
    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);

    // is this a valid ELF?
    //ELF是否有效
    if (ELFHDR-&gt;e_magic != ELF_MAGIC) {
        goto bad;
    }

    struct proghdr *ph, *eph;

    // load each program segment (ignores ph flags)
    //加载每个程序段（忽略ph标志）
    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);
    eph = ph + ELFHDR-&gt;e_phnum;
    for (; ph &lt; eph; ph ++) {
        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);
    }

    // call the entry point from the ELF header
    // note: does not return
    //调用ELF文件头的入口
    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();

bad:
    outw(0x8A00, 0x8A00);
    outw(0x8A00, 0x8E00);

    /* do nothing */
    while (1);
}
</code></pre><h3 id="defs-h"><a href="#defs-h" class="headerlink" title="defs.h"></a>defs.h</h3><pre><code class="C">#ifndef __LIBS_DEFS_H__        //if no define 条件编译
#define __LIBS_DEFS_H__        //如果没有定义则定义一个__LIBS_DEFS_H__

#ifndef NULL
#define NULL ((void *)0)       //定义一个（void *）类型的指针，返回地址0
#endif

#define __always_inline inline __attribute__((always_inline))
#define __noinline __attribute__((noinline))
#define __noreturn __attribute__((noreturn))

/* Represents true-or-false values */    //表示true或false值
typedef int bool;

/* Explicitly-sized versions of integer types */      //exp合法大小的整数类型版本
typedef char int8_t;                                  //字符类型为         8bit
typedef unsigned char uint8_t;                        //无符号字符类型为    8bits
typedef short int16_t;                                   //短整型为           16bits
typedef unsigned short uint16_t;                      //无符号短整型        16bits
typedef int int32_t;                                  //整型              32bits
typedef unsigned int uint32_t;                          //无符号整型         32bits
typedef long long int64_t;                              //长整型             64bits
typedef unsigned long long uint64_t;                  //无符号长整型        64bits

/* *
 * Pointers and addresses are 32 bits long.           //指针和地址为32bits
 * We use pointer types to represent addresses,       //用指针类型表达地址
 * uintptr_t to represent the numerical values of addresses.    //uintptr_t表示地址的数值
 * */                    //32位的机器上，intptr_t和uintptr_t分别是int、unsigned int的别名
                        //提高程序可移植性
typedef int32_t intptr_t;
typedef uint32_t uintptr_t;

/* size_t is used for memory object sizes */         //size_t用于内存对象大小
typedef uintptr_t size_t;

/* used for page numbers */                          //用于页码
typedef size_t ppn_t;

/* *
 * Rounding operations (efficient when n is a power of 2)      //舍入运算（当n为2的幂时有效）
 * Round down to the nearest multiple of n                     //向下舍入到n的最接近的倍数
 * */
#define ROUNDDOWN(a, n) ({                                          \
            size_t __a = (size_t)(a);                               \
            (typeof(a))(__a - __a % (n));                           \
        })

/* Round up to the nearest multiple of n */                 //向上舍入到n的最接近的倍数
#define ROUNDUP(a, n) ({                                            \
            size_t __n = (size_t)(n);                               \
            (typeof(a))(ROUNDDOWN((size_t)(a) + __n - 1, __n));     \
        })

/* Return the offset of &#39;member&#39; relative to the beginning of a struct type */
//返回&#39;member&#39;相对于struct类型开头的偏移量
#define offsetof(type, member)                                      \
    ((size_t)(&amp;((type *)0)-&gt;member))

/* *
 * to_struct - get the struct from a pointer                 //to_struct - 从指针获取结构
 * @ptr:    a struct pointer of member                        //成员的结构指针
 * @type:   the type of the struct this is embedded in      //嵌入的结构的类型
 * @member: the name of the member within the struct         //结构中成员的名称
 * */
#define to_struct(ptr, type, member)                               \
    ((type *)((char *)(ptr) - offsetof(type, member)))

#endif /* !__LIBS_DEFS_H__ */
</code></pre>
<h3 id="x86-h"><a href="#x86-h" class="headerlink" title="x86.h"></a>x86.h</h3><pre><code class="C">#ifndef __LIBS_X86_H__
#define __LIBS_X86_H__

#include &lt;defs.h&gt;


//定义除法
#define do_div(n, base) ({                                      \
    unsigned long __upper, __low, __high, __mod, __base;        \
    __base = (base);                                            \
    asm(&quot;&quot; : &quot;=a&quot; (__low), &quot;=d&quot; (__high) : &quot;A&quot; (n));            \
    __upper = __high;                                           \
    if (__high != 0) {                                          \
        __upper = __high % __base;                              \
        __high = __high / __base;                               \
    }                                                           \
    asm(&quot;divl %2&quot; : &quot;=a&quot; (__low), &quot;=d&quot; (__mod)                  \
        : &quot;rm&quot; (__base), &quot;0&quot; (__low), &quot;1&quot; (__upper));           \
    asm(&quot;&quot; : &quot;=A&quot; (n) : &quot;a&quot; (__low), &quot;d&quot; (__high));             \
    __mod;                                                      \
 })

//定义静态内联函数，将使用inline修饰的函数内容, 内联到函数调用的位置
//inline修饰的函数, 不会再调用这个函数的时候, 调用call方法, 就不会将函数压栈, 产生内存消耗
//内联函数只能对一些小型的函数起作用, 如果函数中消耗的内存很大, 比如for循环, 则内联函数就会默认失效
//访问硬件或寄存器
//inb 从I/O端口读取一个字节(BYTE, HALF-WORD) ;
//outb 向I/O端口写入一个字节（BYTE, HALF-WORD） ;
//insl 从I/O端口读取一个字（WORD，即两个字节） ;
//outw 向I/O端口写入一个字（WORD，即两个字节） ;
//read_ebp 读取扩展基址指针寄存器
static inline uint8_t inb(uint16_t port) __attribute__((always_inline));
static inline void insl(uint32_t port, void *addr, int cnt) __attribute__((always_inline));
static inline void outb(uint16_t port, uint8_t data) __attribute__((always_inline));
static inline void outw(uint16_t port, uint16_t data) __attribute__((always_inline));
static inline uint32_t read_ebp(void) __attribute__((always_inline));

/* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */
//用于LGDT，LLDT（未使用）和LIDT指令的伪描述符
//汇编指令
//LGDT：加载全局描述符
//LLDT：加载局部描述符
//LIDT：加载中断描述符
struct pseudodesc {
    uint16_t pd_lim;        // Limit
    uint32_t pd_base;        // Base address
} __attribute__ ((packed));

//lidt加载中断描述符表
//CLI禁止中断发生
//STI允许中断发生
//LTR指令是专门用于装载任务状态段寄存器TR的指
static inline void lidt(struct pseudodesc *pd) __attribute__((always_inline));
static inline void sti(void) __attribute__((always_inline));
static inline void cli(void) __attribute__((always_inline));
static inline void ltr(uint16_t sel) __attribute__((always_inline));

static inline uint8_t
inb(uint16_t port) {
    uint8_t data;
    asm volatile (&quot;inb %1, %0&quot; : &quot;=a&quot; (data) : &quot;d&quot; (port));
    return data;
}

static inline void
insl(uint32_t port, void *addr, int cnt) {
    asm volatile (
            &quot;cld;&quot;
            &quot;repne; insl;&quot;
            : &quot;=D&quot; (addr), &quot;=c&quot; (cnt)
            : &quot;d&quot; (port), &quot;0&quot; (addr), &quot;1&quot; (cnt)
            : &quot;memory&quot;, &quot;cc&quot;);
}

static inline void
outb(uint16_t port, uint8_t data) {
    asm volatile (&quot;outb %0, %1&quot; :: &quot;a&quot; (data), &quot;d&quot; (port));
}

static inline void
outw(uint16_t port, uint16_t data) {
    asm volatile (&quot;outw %0, %1&quot; :: &quot;a&quot; (data), &quot;d&quot; (port));
}

static inline uint32_t
read_ebp(void) {
    uint32_t ebp;
    asm volatile (&quot;movl %%ebp, %0&quot; : &quot;=r&quot; (ebp));
    return ebp;
}

static inline void
lidt(struct pseudodesc *pd) {
    asm volatile (&quot;lidt (%0)&quot; :: &quot;r&quot; (pd));
}

static inline void
sti(void) {
    asm volatile (&quot;sti&quot;);
}

static inline void
cli(void) {
    asm volatile (&quot;cli&quot;);
}

static inline void
ltr(uint16_t sel) {
    asm volatile (&quot;ltr %0&quot; :: &quot;r&quot; (sel));
}

//定义字符串处理函数
static inline int __strcmp(const char *s1, const char *s2) __attribute__((always_inline));
static inline char *__strcpy(char *dst, const char *src) __attribute__((always_inline));
static inline void *__memset(void *s, char c, size_t n) __attribute__((always_inline));
static inline void *__memmove(void *dst, const void *src, size_t n) __attribute__((always_inline));
static inline void *__memcpy(void *dst, const void *src, size_t n) __attribute__((always_inline));


//asm用来声明一个内联汇编表达式，任何内联汇编表达式都是以它开头，必不可少
//volatile 是可选的，假如用了它，则是向GCC 声明不答应对该内联汇编优化，
//否则当 使用了优化选项(-O)进行编译时，GCC 将会根据自己的判定决定是否将这个内联汇编表达式中的指令优化掉
#ifndef __HAVE_ARCH_STRCMP
#define __HAVE_ARCH_STRCMP
static inline int
__strcmp(const char *s1, const char *s2) {
    int d0, d1, ret;
    asm volatile (
            &quot;1: lodsb;&quot;
            &quot;scasb;&quot;
            &quot;jne 2f;&quot;
            &quot;testb %%al, %%al;&quot;
            &quot;jne 1b;&quot;
            &quot;xorl %%eax, %%eax;&quot;
            &quot;jmp 3f;&quot;
            &quot;2: sbbl %%eax, %%eax;&quot;
            &quot;orb $1, %%al;&quot;
            &quot;3:&quot;
            : &quot;=a&quot; (ret), &quot;=&amp;S&quot; (d0), &quot;=&amp;D&quot; (d1)
            : &quot;1&quot; (s1), &quot;2&quot; (s2)
            : &quot;memory&quot;);
    return ret;
}

#endif /* __HAVE_ARCH_STRCMP */

#ifndef __HAVE_ARCH_STRCPY
#define __HAVE_ARCH_STRCPY
static inline char *
__strcpy(char *dst, const char *src) {
    int d0, d1, d2;
    asm volatile (
            &quot;1: lodsb;&quot;
            &quot;stosb;&quot;
            &quot;testb %%al, %%al;&quot;
            &quot;jne 1b;&quot;
            : &quot;=&amp;S&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;a&quot; (d2)
            : &quot;0&quot; (src), &quot;1&quot; (dst) : &quot;memory&quot;);
    return dst;
}
#endif /* __HAVE_ARCH_STRCPY */

#ifndef __HAVE_ARCH_MEMSET
#define __HAVE_ARCH_MEMSET
static inline void *
__memset(void *s, char c, size_t n) {
    int d0, d1;
    asm volatile (
            &quot;rep; stosb;&quot;
            : &quot;=&amp;c&quot; (d0), &quot;=&amp;D&quot; (d1)
            : &quot;0&quot; (n), &quot;a&quot; (c), &quot;1&quot; (s)
            : &quot;memory&quot;);
    return s;
}
#endif /* __HAVE_ARCH_MEMSET */

#ifndef __HAVE_ARCH_MEMMOVE
#define __HAVE_ARCH_MEMMOVE
static inline void *
__memmove(void *dst, const void *src, size_t n) {
    if (dst &lt; src) {
        return __memcpy(dst, src, n);
    }
    int d0, d1, d2;
    asm volatile (
            &quot;std;&quot;
            &quot;rep; movsb;&quot;
            &quot;cld;&quot;
            : &quot;=&amp;c&quot; (d0), &quot;=&amp;S&quot; (d1), &quot;=&amp;D&quot; (d2)
            : &quot;0&quot; (n), &quot;1&quot; (n - 1 + src), &quot;2&quot; (n - 1 + dst)
            : &quot;memory&quot;);
    return dst;
}
#endif /* __HAVE_ARCH_MEMMOVE */

#ifndef __HAVE_ARCH_MEMCPY
#define __HAVE_ARCH_MEMCPY
static inline void *
__memcpy(void *dst, const void *src, size_t n) {
    int d0, d1, d2;
    asm volatile (
            &quot;rep; movsl;&quot;
            &quot;movl %4, %%ecx;&quot;
            &quot;andl $3, %%ecx;&quot;
            &quot;jz 1f;&quot;
            &quot;rep; movsb;&quot;
            &quot;1:&quot;
            : &quot;=&amp;c&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;S&quot; (d2)
            : &quot;0&quot; (n / 4), &quot;g&quot; (n), &quot;1&quot; (dst), &quot;2&quot; (src)
            : &quot;memory&quot;);
    return dst;
}
#endif /* __HAVE_ARCH_MEMCPY */

#endif /* !__LIBS_X86_H__ */
</code></pre>
<h3 id="elf-h"><a href="#elf-h" class="headerlink" title="elf.h"></a>elf.h</h3><pre><code class="c">#ifndef __LIBS_ELF_H__
#define __LIBS_ELF_H__

#include &lt;defs.h&gt;

#define ELF_MAGIC    0x464C457FU            // &quot;\x7FELF&quot; in little endian

//Magic number： 16字节是用来标识ELF 文件的平台属性，比如字长，字节序，ELF 文件版本。
//在加载的时候，首先会确认魔数的正确性，不正确的话就拒绝加载

/* file header */
struct elfhdr {
    uint32_t e_magic;     // must equal ELF_MAGIC
    uint8_t e_elf[12];
    uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image
    uint16_t e_machine;   // 3=x86, 4=68K, etc.
    uint32_t e_version;   // file version, always 1
    uint32_t e_entry;     // entry point if executable
    uint32_t e_phoff;     // file position of program header or 0
    uint32_t e_shoff;     // file position of section header or 0
    uint32_t e_flags;     // architecture-specific flags, usually 0
    uint16_t e_ehsize;    // size of this elf header
    uint16_t e_phentsize; // size of an entry in program header
    uint16_t e_phnum;     // number of entries in program header or 0
    uint16_t e_shentsize; // size of an entry in section header
    uint16_t e_shnum;     // number of entries in section header or 0
    uint16_t e_shstrndx;  // section number that contains section name strings
};

/* program section header */
struct proghdr {
    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.
    uint32_t p_offset; // file offset of segment
    uint32_t p_va;     // virtual address to map segment
    uint32_t p_pa;     // physical address, not used
    uint32_t p_filesz; // size of segment in file
    uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）
    uint32_t p_flags;  // read/write/execute bits
    uint32_t p_align;  // required alignment, invariably hardware page size
};

#endif /* !__LIBS_ELF_H__ */
</code></pre>
<h1 id="0x05-参考资料"><a href="#0x05-参考资料" class="headerlink" title="0x05 参考资料"></a>0x05 参考资料</h1><p><a href="https://www.jianshu.com/p/2f95d38afa1d" target="_blank" rel="noopener">makefile解析</a><br><a href="https://blog.csdn.net/afei__/article/details/82696682" target="_blank" rel="noopener">makefile语法入门</a></p>

                            <hr>
                        </div>
                        <br>
                        <div>
                            
                            <p>
                                <i class="iconfont icon-tag"></i>
                                
                                    <a class="hover-with-bg" href="/tags/ucore">ucore</a>
                                
                            </p>
                            
                                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
                            
                        </div>
                    </div>
                </div>
            </div>
        <div class="d-none d-lg-block col-lg-2 toc-container">
            
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
    <div class="container comments mx-auto" id="comments">
        
            <br><br>
            
            <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script>               
        var disqus_shortname = '';
        var disqus_config = function () {
            this.page.url = 'http://127.0.0.1:4000/2019/08/29/制作Ucore操作系统/'; 
            this.page.identifier = '/2019/08/29/制作Ucore操作系统/';
        };
        (function() { 
            var d = document, s = d.createElement('script');
            s.type = 'text/javascript';
            s.src = '//'+disqus_shortname+'.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow noopener">comments powered by Disqus.</a></noscript>
</div>
        
    </div>
</div>
    
</main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank" rel="nofollow noopener"> <b>Material-T</b></a>
    <br>
    
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="/lib/mdbootstrap/js/jquery-3.4.1.min.js"></script>
  <script src="/lib/mdbootstrap/js/popper.min.js"></script>
  <script src="/lib/mdbootstrap/js/bootstrap.min.js?v=4.3.1"></script>
  <script src="/lib/mdbootstrap/js/mdb.min.js?v=4.8.7"></script>
  <script src="/lib/nprogress/nprogress.min.js?v=0.2.0"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="/lib/tocbot/tocbot.min.js?v=4.7.0"></script>
    
    <script src="/js/post.js"></script>
  
  
    <script src="/lib/prettify/prettify.min.js?v=0.1.0"></script>
    <script>
      $(document).ready(function(){
        $('pre').addClass('prettyprint linenums');
        prettyPrint();
      })
    </script>
  
  
    <script src="/lib/typed/typed.min.js?v=2.0.9"></script>
    <script>
        var typed = new Typed('#subtitle', {
          strings: [
            '  ',
            "一步一步构建Ucore操作系统(Lab 1)&nbsp;",
        ],
        cursorChar: "_",
        typeSpeed: 70,
        startDelay: 300, //开始之前延迟300毫秒
        loop: false,
        });
        $(".typed-cursor").addClass("h2");
    </script>
  
  
    <script src="/lib/anchor/anchor.min.js?v=4.2.0"></script>
    <script>
      anchors.options = {
        placement: "right",
        visible: "true",
        
      };
      anchors.add(".post-content > h1,h2,h3,h4,h5,h6");
    </script>
  

  
</body>
</html>
